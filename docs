# FSO Vulkan 1.4 Backend Architecture

## Overview

This document describes the architecture of the FreeSpace 2 Open Vulkan 1.4 backend. The implementation targets modern Vulkan features to minimize overhead and maximize performance.

## Core Principles

1. **Push descriptors for per-draw data** - No descriptor pools in hot path
2. **Dynamic rendering** - No VkRenderPass, no VkFramebuffer
3. **Sync2 + timeline semaphores** - Modern synchronization primitives
4. **Aggressive dynamic state** - Minimize pipeline permutations
5. **Unified shader source** - Existing SPIR-V build pipeline, shared with OpenGL

---

## Descriptor Layout

### Set 0: Per-Draw Push Descriptors

**Why Set 0:** The shaders use `layout(binding = N)` without specifying `set = N`, which defaults to `set = 0` in GLSL/Vulkan. This is a hard requirement - push descriptors MUST be in set 0 to match the shader expectations.

**Bindings:**
- `binding = 0`: `matrixData` UBO (matrices)
- `binding = 1`: `genericData` UBO (per-draw material data)
- `binding = 2+`: Material textures (basemap, normalmap, specmap, etc.)

**Implementation:** Uses `vkCmdPushDescriptorSetKHR` extension. No descriptor pool allocation needed.

### Set 1: Global Descriptors

**Bindings:**
- `binding = 0`: `shadow_map` (sampler2DShadow)
- `binding = 1`: `envmap` (samplerCube)
- `binding = 2`: Noise LUT, etc.

**Implementation:** Traditional descriptor set, allocated once and bound per frame.

---

## Pipeline Architecture

### Pipeline Key

```cpp
struct PipelineKey {
    shader_type type;
    uint32_t variant_flags;
    VkFormat color_format;
    VkFormat depth_format;
    VertexLayout layout;
    // Blend/depth/cull handled via dynamic state, NOT in key
};
```

### Dynamic State

**Core 1.3 Dynamic State (use unconditionally):**
- `VK_DYNAMIC_STATE_VIEWPORT`
- `VK_DYNAMIC_STATE_SCISSOR`
- `VK_DYNAMIC_STATE_CULL_MODE`
- `VK_DYNAMIC_STATE_FRONT_FACE`
- `VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE`
- `VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE`
- `VK_DYNAMIC_STATE_DEPTH_COMPARE_OP`
- `VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE`
- `VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY` (with `dynamicPrimitiveTopologyUnrestricted` if available)

**Optional Extended Dynamic State 3 (query at init):**
- `VK_DYNAMIC_STATE_BLEND_ENABLE`
- `VK_DYNAMIC_STATE_COLOR_WRITE_MASK`
- `VK_DYNAMIC_STATE_POLYGON_MODE`
- `VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES`

**Note:** Since we require Vulkan 1.4, core 1.3 dynamic state features should be used unconditionally. Only EDS3 features need extension checks.

### Pipeline Creation

```cpp
VkPipelineRenderingCreateInfo renderingInfo{};
renderingInfo.colorAttachmentCount = 1;
renderingInfo.pColorAttachmentFormats = &key.color_format;
renderingInfo.depthAttachmentFormat = key.depth_format;

VkGraphicsPipelineCreateInfo pipelineInfo{};
pipelineInfo.pNext = &renderingInfo;
pipelineInfo.renderPass = VK_NULL_HANDLE;  // Dynamic rendering
```

**Pipeline Cache:** Uses `vulkan_pipeline.cache` file for persistence across runs.

---

## Frame Structure

### VulkanFrame Class

```cpp
class VulkanFrame {
    vk::UniqueCommandPool command_pool;      // Reset per frame
    vk::CommandBuffer primary_cmd;             // Pre-allocated, reused
    
    vk::UniqueSemaphore timeline_semaphore;    // Single timeline for frame pacing
    uint64_t timeline_value;                   // Incremented each frame
    
    vk::UniqueSemaphore image_available;       // Binary, required by WSI
    vk::UniqueSemaphore render_finished;       // Binary, required by WSI
    
    VulkanUniformRingBuffer uniform_buffer;    // Uniform ring buffer (sub-allocated per draw)
};
```

**Constants:**
- `MAX_FRAMES_IN_FLIGHT = 2`
- `UNIFORM_RING_SIZE = 512 KB`

### Frame Flow

```cpp
void flip() {
    auto& frame = *m_frames[m_currentFrame];
    
    // 1. Wait for this frame's previous use to complete
    frame.wait_for_gpu();  // Waits on timeline semaphore
    
    // 2. Reset command pool (resets all buffers allocated from it)
    frame.reset();
    
    // 3. Acquire swapchain image
    uint32_t imageIndex = acquireImage(frame);
    
    // 4. Record commands
    recordFrame(frame, imageIndex);
    
    // 5. Submit and present
    submitFrame(frame, imageIndex);
    
    m_currentFrame = (m_currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}
```

### Timeline Semaphore Flow

1. **Wait:** `wait_for_gpu()` waits for `timeline_value` to be signaled
2. **Signal:** Submit signals `timeline_value + 1` 
3. **Advance:** After present, increment `timeline_value`

**Note:** Current implementation signals `nextTimelineValue()` (value + 1) then advances. This works but is unconventional - typically you'd increment first then signal.

---

## Uniform Ring Buffer

### Allocation Strategy

Per-frame host-visible buffer (512 KB) that sub-allocates uniform data:

```cpp
struct Allocation {
    vk::DeviceSize offset;
    void* mapped;  // Direct pointer to mapped memory
};

Allocation allocate(vk::DeviceSize size, vk::DeviceSize alignmentOverride = 0);
void reset();  // Reset offset to 0 at start of frame
```

**Alignment:** Enforced by caller. Uses `minUniformBufferOffsetAlignment` from device limits.

**Usage Pattern:**
```cpp
auto matrixAlloc = frame.uniformBuffer().allocate(sizeof(matrices), 256);
std::memcpy(matrixAlloc.mapped, &matrices, sizeof(matrices));
// Use matrixAlloc.offset in descriptor buffer info
```

---

## Draw Path

### Per-Draw Call Sequence

```cpp
void draw_model(vk::CommandBuffer cmd, const DrawCall& draw) {
    // 1. Write uniforms to ring buffer
    auto matrixAlloc = frame.uniformBuffer().allocate(sizeof(matrixData), alignment);
    memcpy(matrixAlloc.mapped, &draw.matrices, sizeof(matrixData));
    
    auto genericAlloc = frame.uniformBuffer().allocate(sizeof(genericData), alignment);
    memcpy(genericAlloc.mapped, &draw.generic, sizeof(genericData));
    
    // 2. Push descriptors (no allocation, no pools)
    VkDescriptorBufferInfo matrix_info = {
        uniform_buffer, matrixAlloc.offset, sizeof(matrixData)
    };
    VkDescriptorBufferInfo generic_info = {
        uniform_buffer, genericAlloc.offset, sizeof(genericData)
    };
    VkDescriptorImageInfo texture_info = {
        sampler, draw.texture_view, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
    };
    
    VkWriteDescriptorSet writes[] = {
        {.dstBinding = 0, .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 
         .pBufferInfo = &matrix_info},
        {.dstBinding = 1, .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
         .pBufferInfo = &generic_info},
        {.dstBinding = 2, .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
         .pImageInfo = &texture_info},
    };
    vkCmdPushDescriptorSetKHR(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, 
                               pipeline_layout, 0, 3, writes);
    
    // 3. Set dynamic state
    vkCmdSetCullMode(cmd, draw.cull_mode);
    vkCmdSetDepthTestEnable(cmd, draw.depth_test);
    vkCmdSetDepthWriteEnable(cmd, draw.depth_write);
    
    // 4. Bind pipeline (cached by shader_type + formats)
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, 
                      get_pipeline(draw.key));
    
    // 5. Bind vertex/index buffers, draw
    vkCmdBindVertexBuffers(cmd, 0, 1, &draw.vertex_buffer, &draw.vertex_offset);
    vkCmdBindIndexBuffer(cmd, draw.index_buffer, draw.index_offset, 
                        VK_INDEX_TYPE_UINT16);
    vkCmdDrawIndexed(cmd, draw.index_count, 1, 0, 0, 0);
}
```

---

## Rendering a Frame

### Dynamic Rendering Setup

```cpp
void recordFrame(VulkanFrame& frame, uint32_t imageIndex) {
    vk::CommandBuffer cmd = frame.commandBuffer();
    cmd.begin({vk::CommandBufferUsageFlagBits::eOneTimeSubmit});
    
    // 1. Transition swapchain image to color attachment
    vk::ImageMemoryBarrier2 to_render = {
        .srcStageMask = vk::PipelineStageFlagBits2::eTopOfPipe,
        .dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput,
        .dstAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite,
        .oldLayout = vk::ImageLayout::eUndefined,
        .newLayout = vk::ImageLayout::eColorAttachmentOptimal,
        .image = swapchain_images[imageIndex],
        .subresourceRange = {vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1}
    };
    vk::DependencyInfo dep = {
        .imageMemoryBarrierCount = 1,
        .pImageMemoryBarriers = &to_render
    };
    cmd.pipelineBarrier2(dep);
    
    // 2. Begin dynamic rendering
    vk::RenderingAttachmentInfo color_attach = {
        .imageView = swapchain_image_views[imageIndex],
        .imageLayout = vk::ImageLayout::eColorAttachmentOptimal,
        .loadOp = vk::AttachmentLoadOp::eClear,
        .storeOp = vk::AttachmentStoreOp::eStore,
        .clearValue = vk::ClearColorValue({0, 0, 0, 1})
    };
    
    // TODO: Add depth attachment when depth_format != VK_FORMAT_UNDEFINED
    
    vk::RenderingInfo rendering = {
        .renderArea = {{0, 0}, swapchain_extent},
        .layerCount = 1,
        .colorAttachmentCount = 1,
        .pColorAttachments = &color_attach,
    };
    cmd.beginRendering(rendering);
    
    // 3. Bind global descriptors once (set 1)
    cmd.bindDescriptorSets(vk::PipelineBindPoint::eGraphics, pipeline_layout,
                           1, 1, &global_descriptor_set, 0, nullptr);
    
    // 4. Draw everything (push descriptors happen per-draw)
    for (const auto& draw : scene_draws) {
        draw_model(cmd, draw);
    }
    
    cmd.endRendering();
    
    // 5. Transition to present
    to_render.srcStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput;
    to_render.srcAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite;
    to_render.dstStageMask = vk::PipelineStageFlagBits2::eBottomOfPipe;
    to_render.dstAccessMask = {};
    to_render.oldLayout = vk::ImageLayout::eColorAttachmentOptimal;
    to_render.newLayout = vk::ImageLayout::ePresentSrcKHR;
    cmd.pipelineBarrier2(dep);
    
    cmd.end();
}
```

### Submission and Presentation

```cpp
void submitFrame(VulkanFrame& frame, uint32_t imageIndex) {
    // 1. Prepare submit info with Sync2
    vk::CommandBufferSubmitInfo cmdInfo;
    cmdInfo.commandBuffer = frame.commandBuffer();
    
    vk::SemaphoreSubmitInfo waitSemaphore = {
        .semaphore = frame.imageAvailable(),
        .stageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput
    };
    
    vk::SemaphoreSubmitInfo signalSemaphores[2] = {
        {
            .semaphore = frame.renderFinished(),
            .stageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput
        },
        {
            .semaphore = frame.timelineSemaphore(),
            .value = frame.nextTimelineValue(),  // current + 1
            .stageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput
        }
    };
    
    vk::SubmitInfo2 submitInfo = {
        .waitSemaphoreInfoCount = 1,
        .pWaitSemaphoreInfos = &waitSemaphore,
        .commandBufferInfoCount = 1,
        .pCommandBufferInfos = &cmdInfo,
        .signalSemaphoreInfoCount = 2,
        .pSignalSemaphoreInfos = signalSemaphores
    };
    
    // 2. Submit
    graphics_queue.submit2(submitInfo, vk::Fence());
    
    // 3. Present (binary semaphore required by WSI)
    vk::PresentInfoKHR presentInfo = {
        .waitSemaphoreCount = 1,
        .pWaitSemaphores = &frame.renderFinished(),
        .swapchainCount = 1,
        .pSwapchains = &swapchain,
        .pImageIndices = &imageIndex
    };
    present_queue.presentKHR(presentInfo);
    
    // 4. Advance timeline
    frame.advanceTimeline();
}
```

---

## File Structure

```
code/graphics/vulkan/
‚îú‚îÄ‚îÄ VulkanRenderer.cpp/h      - Main renderer class, initialization, frame loop
‚îú‚îÄ‚îÄ VulkanFrame.cpp/h          - Per-frame resources (command pool, semaphores, uniform buffer)
‚îú‚îÄ‚îÄ VulkanPipelineManager.cpp/h - Pipeline cache, creation, key-based lookup
‚îú‚îÄ‚îÄ VulkanShaderManager.cpp/h   - SPIR-V loading, module cache
‚îú‚îÄ‚îÄ VulkanDescriptorLayouts.cpp/h - Descriptor set layouts, pipeline layout
‚îú‚îÄ‚îÄ VulkanUniformRingBuffer.cpp/h - Uniform buffer sub-allocation
‚îú‚îÄ‚îÄ gr_vulkan.cpp/h            - Backend entry points, function pointer setup
‚îî‚îÄ‚îÄ vulkan_stubs.cpp/h         - Stub implementations for unimplemented features
```

---

## Required Extensions

### Instance Extensions
- `VK_KHR_surface`
- `VK_KHR_win32_surface` (or platform-specific)
- `VK_EXT_debug_utils` (optional, for validation)

### Device Extensions (Required)
- `VK_KHR_swapchain`
- `VK_KHR_push_descriptor`
- `VK_KHR_maintenance5`

### Device Extensions (Optional)
- `VK_EXT_extended_dynamic_state3` (for additional dynamic state)

### Device Features (Required)
- Vulkan 1.4 API version
- `VkPhysicalDeviceVulkan12Features::timelineSemaphore`
- `VkPhysicalDeviceVulkan13Features::synchronization2`
- `VkPhysicalDeviceVulkan13Features::dynamicRendering`
- `VkPhysicalDeviceVulkan14Features::maintenance5`

---

## Shader Compatibility

### GLSL to SPIR-V Mapping

The shaders are written in GLSL with `layout(binding = N)` qualifiers. When compiled to SPIR-V:

- Bindings without `set = N` default to `set = 0`
- This is why push descriptors MUST be in set 0
- Global descriptors use set 1 (requires shader modification or separate shader variants)

### Example Shader Bindings

```glsl
// default-material.vert
layout (binding = 0, std140) uniform matrixData { ... };  // Set 0
layout (binding = 1, std140) uniform genericData { ... };  // Set 0

// default-material.frag
layout (binding = 1, std140) uniform genericData { ... };  // Set 0
layout(binding = 2) uniform sampler2DArray baseMap;       // Set 0
```

---

## Implementation Status

### ‚úÖ Implemented
- Push descriptors (set 0)
- Dynamic rendering
- Sync2 + timeline semaphores
- Pipeline cache
- Uniform ring buffer
- Frame structure
- Basic triangle rendering

### ‚ö†Ô∏è Known Issues
- Missing error handling in `acquireImage()`
- Missing depth attachment support (pipeline key has it but not used)
- Dynamic state checks for core 1.3 features (should be unconditional)
- Incomplete swapchain recreation
- Some misleading comments

### üî≤ TODO
- Port all draw calls from OpenGL backend
- Implement texture management
- Add depth/stencil support
- Implement all shader types
- Performance optimization
- Error handling improvements

---

## References

- [Vulkan 1.4 Specification](https://www.khronos.org/registry/vulkan/specs/1.4/html/)
- [VK_KHR_push_descriptor Extension](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_push_descriptor.html)
- [VK_KHR_dynamic_rendering Extension](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_dynamic_rendering.html)
- [Vulkan Synchronization2](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSubmitInfo2.html)

